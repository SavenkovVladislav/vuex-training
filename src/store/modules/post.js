export default {
	//для работы с бэком необходимо использовать объект actions

	//О передачи параметров в экшены:
	//чтобы передать параметры в экшен необходимо второму параметру функции-экшену(в нашем случае это fetchPosts) передать какую-то переменную, в нашем случае эта переменная называется limit. Теперь нам необходимо динамически управлять этим параметром из компонента app. Это делается в том месте, где мы вызываем данный экшен
	actions: {
		//логика того, что происходит в функции fetchPosts описана в файле AppWithoutVuex
		async fetchPosts(ctx, limit = 3) {
			const res = await fetch(
				'https://jsonplaceholder.typicode.com/posts?_limit=' + limit
			)
			const posts = await res.json()

			//теперь необходимо вызвать мутацию updatePosts, которая описана в объекте mutations
			//для этого в акшене fetchPosts мы можем использовать специальный контекст, который называется ctx
			//у контекста есть метод, который называется commit. В первый параметр метода commit необходимо передать название той мутации, которую необходимо вызвать, в нашем случае это updatePosts, а во второй параметр метода commit необходимо передать распаршенные данные, которые лежат в константе posts, которая описана выше
			ctx.commit('updatePosts', posts)

			//теперь данный экшен, который называется fetchPosts необходимо вызвать. Делать это необходимо в компоненте app, например в методе mounted
		},
	},

	mutations: {
		//объект mutations содержит в себе функции, которые будут напрямую изменять state
		//чтобы добавить данные полученные с сервера, которые лежат в константе posts, которая описана выше необходимо добавить в объект mutations функцию
		//в мутации всегда первым параметром будет state, а второй параметрр это то, что мы будем в него передавать
		//далее необходимо вызвать данную мутацию. Это будет происходить в объекте actions

		updatePosts(state, posts) {
			state.posts = posts
		},
	},
	state: {
		//объект state необходим для обозначения изначальных или каки-либо других данных в приложении
		//заданим начальный state для приложения как массив posts
		posts: [],
	},
	getters: {
		//объект getters позволяет трансформировать и получать данные из store
		//как сказано выше объект getters позволяет изменять и получать данные из store. Для этого необходимо определить новое поле в getters, чтобы получить какие-то данные
		//заведем новый геттер, который является обычной функцией, которая забирает данные из state и возвращает как данные. Такой функцией в нашем случае будет функция allPosts
		//данная функция первым параметром принимает в себя некоторый state, который является объектом state, который объявлен выше. Возвращает данная функция массив posts, который лежит в state, который описан выше
		//после создания геттера allPosts к нему можно обратиться в компоненте app
		allPosts(state) {
			return state.posts
		},
		postsCount(state) {
			return state.posts.length
		},
	},
}
